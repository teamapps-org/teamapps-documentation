<page>
  <body>
  <h3 id="TemplatesAndDataExtraction">Templates and Data Extraction</h3>

  <h4 id="GeneralConcept">General concept</h4>
  <p>
    This section shows how any kind of object can be displayed within TeamApps UI components in a custom way.
    To achieve this, we use Templates and data extraction tools. In the below example, the general principle is applied
    to the simplest component, the TemplateField, where we want to display an Animal object. <br>
    Templates define how data properties are displayed on the UI. The set of properties a template is based on can be
    accessed via the {getPropertyNames} method which every template must implement. Here, we use one of the predefined
    BaseTemplates which are based on the GridTemplate (see section <a href="#GridTemplate">Grid Template</a>).
    The BaseTemplate LIST_ITEM_LARGE_ICON_TWO_LINES has the propertyNames: [icon, image, caption, description, badge,
    ariaLabel, title]. <br>
    Data extraction tools comprise the PropertyProvider and its subinterface the PropertyExtractor. Both serve as
    mappers of the templates propertyNames to object specific information (e.g. its attributes) we want to display.
    Below, we implement a PropertyExtractor by defining this mapping in its {getValue} method. The PropertyProvider has
    a similar mapping function called {getValues} which returns a mapping of all propertyNames at once. <br>
    Note: in the example below, the title occurs in the mouseover popup.
  </p>
  <example th:with="class='org.teamapps.documentation.example.templates.TemplateFieldExample'"></example>
  <p>
    If no custom PropertyProvider or Extractor is set in a component, the BeanPropertyExtractor which implements the
    PropertyExtractor is used as a default. Its {getValue} method is based on the ValueExtractor interface whose instances
    are record class and propertyName specific. More precisely, its {extract} method returns the respective
    propertyName specific value for a record. <br>
    If there is no custom ValueExtractor for a given propertyName in a BeanPropertyExtractor instance, a
    ValueExtractor is created for the class of the record and the propertyName if a getter named according to the
    propertyName can be found within the class (and if fallbackToFields attribute is True, it also tries to match the
    field names of the class). Thus, in the example, description and icon of the animal class would be displayed
    automatically, since the attribute names match the propertyNames.
    However, a template's propertyNames are not suitable as attribute names of the Objects that should be represented.
    In that case, we can either define a custom PropertyProvider or extractor as in the previous example or alternatively
    add custom ValueExtractors for specific propertyNames to the BeanPropertyExtractor via the {addProperty} method. In
    the below example, we pass ValueExtractors for the caption, image and badge properties.

  <p style="color:red;">TODO: Property Injection</p>

  </p>
  <example th:with="class='org.teamapps.documentation.example.templates.BeanPropertyExtractorExample'"></example>
  <h4 id="GridTemplate">GridTemplate</h4>
  <p>
    TODO
  </p>
  <!--<example th:with="class='org.teamapps.documentation.example.templates.GridTemplateExample'"></example>-->
  <h4 id="ComboBoxWithTemplate">ComboBox with Template</h4>
  <p style="color:red;">TODO: refactor the following content according to the new TOC, remove unnecessary examples</p>
  <!--<example th:with="class='org.teamapps.documentation.example.databinding.ComboboxWithTemplateExample'"></example>-->
  <p>
    A combo box is a drop-down list selection input with search functionality. In Teamapps, the display of
    objects in a combo box is very configurable, so it can go far beyond a simple string representation.
  </p>
  <h5 id="instantiation">Creating a ComboBox instance</h5>
  <p>
    A combo box can be instantiated using one of its static factory methods which can either get the record data
    from an Enum class or a List.
  </p>
  <example th:with="class='org.teamapps.documentation.example.combobox.ComboBoxCreateForEnum'"></example>
  <p>
    If not otherwise configured, a string representation of the objects is displayed in the list. In the below
    example, this representation is the output of the toString method.
  </p>
  <example th:with="class='org.teamapps.documentation.example.combobox.ComboBoxCreateForList'"></example>
  <h5 id="recordToStringFunction">RecordToStringFunction</h5>
  <p>
    Internally, these factory methods implement a ComboBoxModel which has only one method, the getRecords method.
    It matches a query string to the string representation of the records returned by recordToStringFunction
    which can be set as a ComboBox attribute. So in the below example, the user can in particular search for an
    animal of a certain height. The string representation is also distinct for small animals. If the
    recordToStringFunction is not set, the toString method of the record class is the default.
  </p>
  <example th:with="class='org.teamapps.documentation.example.combobox.ComboBoxSetRecordToString'"></example>
  <h5 id="ComboBoxModel">ComboBoxModel</h5>
  <p>
    Instead of the above-mentioned default model which may be set upon ComboBox creation, a custom model can
    also be set. The below example furthermore demonstrates its getRecords functionality. Since the query is
    concatenated with the name attribute which in turn is used in the toString method of the Animal class, you
    can see your search term appear in the record list. Give it a try, for instance by typing in "Awesome".
  </p>
  <example th:with="class='org.teamapps.documentation.example.combobox.ComboBoxSetModel'"></example>
  <h5 id="HierarchicalData">Hierarchical data</h5>
  <p>
    You can also display hierarchical data in a ComboBox as the ComboBoxModel inherits i.a. the getTreeNodeInfo
    method from the BaseTreeModel which must be overridden if the record is not already of type TreeNode. For a
    record, this method returns the TreeNodeInfo containing in particular information about the identity of its
    parent. Other settings are optional. By default, children of a parent node are not shown, but the sublist
    can be expanded pressing the arrow right key when the parent record is highlighted. In case the children are
    lazy, they are not sent to the client.
  </p>
  <example th:with="class='org.teamapps.documentation.example.combobox.ComboBoxTree'"></example>
  <h5 id="TemplatesAndPropertyExtractor">Templates and PropertyExtractor<a class="" href="#TemplatesAndPropertyExtractor" title="">Â¶</a></h5>
  <h6 id="BaseTemplate">BaseTemplate</h6>
  <p>
    The representation of records in a ComboBox is even more configurable considering that we have displayed the
    entries only as strings so far. Teamapps offers numerous templates that serve as placeholders for properties
    that are displayed in a defined way. The BaseTemplate Enum class comprises a set of default templates that
    are based on the GridTemplate(...). You can see that the icon and
    the description attributes of the Animal objects are now shown in the drop-down list. This only happens
    because those attributes (coincidentally) match the corresponding property names of the Template (TODO: refer to BeanPropertExtractor). You can find
    out about a template's property names from its getPropertyNames method which must be implemented when using the
    Template interface. For instance the below BaseTemplate.LIST_ITEM_LARGE_ICON_TWO_LINES has this list of
    property names: [icon, image, caption, description, badge, ariaLabel, title].
  </p>
  <example th:with="class='org.teamapps.documentation.example.combobox.ComboBoxBaseTemplate'"></example>
  <h6 id="PropertyExtractor">PropertyExtractor</h6>
  <p>
    Although you could just adopt the attribute names of your record class to the property names of the template
    you want to use it with, this should not be a requirement in the choice of attribute names. Therefore, there
    is a PropertyExtractor available to map the template's property names to object specific information.
    Note: in the example below, the title occurs in the mouseover popup.
  </p>
  <example th:with="class='org.teamapps.documentation.example.combobox.ComboBoxPropertyProvider'"></example>
  <h6 id="MustacheTemplate">MustacheTemplate</h6>
  <p>
    The MustacheTemplate is instantiated with a html string that the property names are extracted from. This
    is done by applying a regular expression that splits the html string at curly braces. In the below example,
    the property names color, iconSize, icon and caption are thus extracted. At the same time, the html string
    also defines the way the properties of the records are displayed in the ComboBox.
  </p>
  <example th:with="class='org.teamapps.documentation.example.combobox.ComboBoxMustacheTemplate'"></example>
  <h6 id="TemplateDecider">TemplateDecider</h6>
  <p>
    It is possible to set different templates for different records. For that purpose, you can set a general
    TemplateDecider, but you can also further distinguish between the records in the drop-down list and the
    record selected by the user which is demonstrated below.
  </p>
  <example th:with="class='org.teamapps.documentation.example.combobox.ComboBoxTemplateDecider'"></example>
  <h4 id="ButtonWithTemplate">Button with Template</h4>
  <p>
    The main features to display on a button might be an icon and a caption. There are factory methods where you can
    pass just (one of) these parameters and a BaseTemplateRecord will be created from them as the record entry of the
    button and BaseTemplate called BUTTON will be used for display. We can also add a Component which expands upon
    clicking the button. This is shown in the upper button example. <br>
    Like in previously presented components, we can also display a custom record object on a button. For the arrangement
    of the properties, we can for instance use one of the several button related predefined BaseTemplates and use set a
    propertyProvider that maps selected information of the record onto the button (see second button example).
    In a later section, we will see how to use buttons in a <a href="#ToolbarWithTemplate">toolbar with templates</a>.
  </p>
  <example th:with="class='org.teamapps.documentation.example.templates.ButtonWithTemplateExample'"></example>
  <h4 id="ItemViewWithTemplate">ItemView with Template</h4>
  <p>
    An ItemView object contains a List of ItemGroups. Both have the same two generic Types, RECORD and a HEADERRECORD.
    Accordingly, an ItemGroup object contains an items list of RECORDS and a headerRecord as attributes. The default
    BaseTemplate of the groupHeader, the LIST_ITEM_SMALL_ICON_SINGLE_LINE, is set in the ItemView class  and the default
    BaseTemplate of the items, the ITEM_VIEW_ITEM, is set in ItemGroup class.
  </p>
  <example th:with="class='org.teamapps.documentation.example.templates.ItemViewWithTemplateExample'"></example>
  <h4 id="ToolbarWithTemplate">Toolbar with Template</h4>
  <p>
    TODO
  </p>
  <!--<example th:with="class='org.teamapps.documentation.example.templates.ToolbarWithTemplateExample'"></example>-->
  </body>
</page>